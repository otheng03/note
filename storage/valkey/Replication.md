# Replication

```C
typedef struct replBufBlock {
    int refcount;          /* Number of replicas or repl backlog using. */
    long long id;          /* The unique incremental number. */
    long long repl_offset; /* Start replication offset of the block. */
    size_t size, used;
    char buf[];
} replBufBlock;

```

The size limit of replBufBlock:

```C
/* Avoid creating nodes smaller than PROTO_REPLY_CHUNK_BYTES, so that we can append more data into them,
 * and also avoid creating nodes bigger than repl_backlog_size / 16, so that we won't have huge nodes that
 * can't trim when we only still need to hold a small portion from them. */
size_t limit = max((size_t)server.repl_backlog_size / 16, (size_t)PROTO_REPLY_CHUNK_BYTES);
size_t size = min(max(len, (size_t)PROTO_REPLY_CHUNK_BYTES), limit);
```


# CHILD INFO EVENT

```
  Flow:

  PSYNC command (syncCommand)
      ↓
  Partial resync not possible → Full sync needed
      ↓
  startBgsaveForReplication()  [replication.c:961]
      ↓
  rdbSaveToReplicasSockets()   [rdb.c:3549]
      ↓
  fork() → Child process streams RDB to replicas
      ↓
  sendChildInfoGeneric(CHILD_INFO_TYPE_REPL_OUTPUT_BYTES, ...)  [rdb.c:3656]
```

Why it happens:

1. When a replica sends PSYNC and a full resync is required (can't do partial sync), the primary needs to send the entire RDB snapshot
2. The primary forks a child process (rdbSaveToReplicasSockets) to serialize and stream the RDB data to replicas without blocking the main server
3. The child reports back to the parent via the child_info_pipe:
  - CHILD_INFO_TYPE_RDB_COW_SIZE - Copy-on-Write memory stats
  - CHILD_INFO_TYPE_REPL_OUTPUT_BYTES - How many bytes were sent (only in dual-channel mode, line 3655-3656)
4. The parent receives these stats via receiveChildInfo() to track replication progress and memory usage

Specifically for dual-channel replication (line 3655-3656): the REPL_OUTPUT_BYTES event is sent so the parent knows how much data was transferred, which gets stored in server.stat_net_repl_output_bytes for monitoring/stats purposes.


# PSYNC

options:
- repl-diskless-sync 

commands.def:
```
{MAKE_CMD("psync","An internal command used in replication.",NULL,"2.8.0",CMD_DOC_NONE,NULL,NULL,"server",COMMAND_GROUP_SERVER,PSYNC_History,0,PSYNC_Tips,0,syncCommand,-3,CMD_NO_ASYNC_LOADING|CMD_ADMIN|CMD_NO_MULTI|CMD_NOSCRIPT,ACL_CATEGORY_ADMIN|ACL_CATEGORY_DANGEROUS|ACL_CATEGORY_SLOW,NULL,PSYNC_Keyspecs,0,NULL,2),.args=PSYNC_Args},
```

client:
```
REPLCONF listening-port 41804
REPLCONF ip-address 127.0.0.1
REPLCONF capa eof
REPLCONF capa psync2
PSYNC ? -1
```

valkey-server:
```
void syncCommand(client *c)

int startBgsaveForReplication(int mincapa, int req) {
  int rdbSaveToReplicasSockets(int req, rdbSaveInfo *rsi)
    listRewind(server.replicas, &li);
    while ((ln = listNext(&li))) {
      replicationSetupReplicaForFullResync(replica, getPsyncInitialOffset())  // Before
    }

    if ((childpid = serverFork(CHILD_TYPE_RDB)) == 0) {
      int rdbSaveRioWithEOFMark(int req, rio *rdb, int *error, rdbSaveInfo *rsi) {
        void startSaving(int rdbflags) {
          void moduleFireServerEvent(uint64_t eid, int subid, void *data) {}
        }
        rioWrite(rdb, "$EOF:", 5)
        rioWrite(rdb, eofmark, RDB_EOF_MARK_SIZE)
        rioWrite(rdb, "\r\n", 2)
        rdbSaveRio(req, rdb, error, RDBFLAGS_REPLICATION, rsi) == C_ERR) {
          rdbWriteRaw(rdb, magic, 9)
          rdbSaveInfoAuxFields(rdb, rdbflags, rsi)
          for (j = 0; j < server.dbnum; j++) {
            rdbSaveDb(rdb, j, rdbflags, &key_counter) {
              while (kvstoreIteratorNext(kvs_it, &next)) { 
                int curr_slot = kvstoreIteratorGetCurrentHashtableIndex(kvs_it);
                  rdbSaveKeyValuePair(rdb, &key, o, expire, dbid)
              }
            }
          }
          rdbSaveType(rdb, RDB_OPCODE_EOF)
          rioWrite(rdb, &cksum, 8)
        }
        rioWrite(rdb, eofmark, RDB_EOF_MARK_SIZE)
      }
    }
```

# rdbSaveRio
**Generated by CLAUDE, TODO: Accuracy must be verified**
```
⏺ RDBFLAGS Explained in Detail

  These flags control how RDB data is saved or loaded depending on the context (normal
  persistence, replication, AOF, debugging). They're bitmask flags that can be combined with |.

  Visual Overview

                           ┌─────────────────────────────────────────────┐
                           │           RDB Save/Load Contexts            │
                           └─────────────────────────────────────────────┘
                                              │
          ┌───────────────────┬───────────────┼───────────────┬──────────────────┐
          ▼                   ▼               ▼               ▼                  ▼
     ┌─────────┐      ┌──────────────┐  ┌───────────┐  ┌─────────────┐   ┌────────────┐
     │ BGSAVE  │      │ AOF Rewrite  │  │   SYNC    │  │DEBUG RELOAD │   │  Startup   │
     │(to disk)│      │  (preamble)  │  │(to replica│  │   (merge)   │   │ (from disk)│
     └────┬────┘      └──────┬───────┘  └─────┬─────┘  └──────┬──────┘   └─────┬──────┘
          │                  │                │               │                │
     RDBFLAGS_NONE    AOF_PREAMBLE      REPLICATION      ALLOW_DUP         FEED_REPL
                                       + KEEP_CACHE                       (if primary)

  ---
  Flag-by-Flag Breakdown

  RDBFLAGS_NONE (0)

  Standard RDB save to disk (BGSAVE, SAVE). No special handling.

  ---
  RDBFLAGS_AOF_PREAMBLE (1 << 0)

  When: RDB is embedded at the start of an AOF file for faster loading.

  Effects:
  - Sets aof-base AUX field to 1 (line rdb.c:1244)
  - Progress logs say "AOF rewrite" instead of "RDB" (rdb.c:1372)
  - Modules receive SUBEVENT_LOADING_AOF_START instead of LOADING_RDB_START
  - Skips deleting expired keys during load (rdb.c:3441) — AOF commands after the preamble handle
  expiration properly

  AOF file structure with preamble:
  ┌───────────────────────────┐
  │  RDB snapshot (preamble)  │  ← RDBFLAGS_AOF_PREAMBLE
  ├───────────────────────────┤
  │  AOF commands...          │
  │  SET foo bar              │
  │  INCR counter             │
  └───────────────────────────┘

  ---
  RDBFLAGS_REPLICATION (1 << 1)

  When: Full sync from primary to replica.

  Effects:
  - Includes transient cluster state like open slots (cluster_legacy.c:8066) — this data shouldn't
   persist to disk but must transfer during sync
  - Modules receive SUBEVENT_LOADING_REPL_START
  - Often combined with KEEP_CACHE since the replica will read the file immediately

  // replication.c:976 — generating RDB for replica
  rdbSaveBackground(req, server.rdb_filename, rsiptr,
                    RDBFLAGS_REPLICATION | RDBFLAGS_KEEP_CACHE);

  ---
  RDBFLAGS_ALLOW_DUP (1 << 2)

  When: DEBUG RELOAD MERGE — reload RDB without flushing existing keys.

  Effects:
  - Duplicate keys don't cause errors; they overwrite existing ones (rdb.c:3465)
  - Functions/libraries with same name are allowed (rdb.c:3055)

  Before:  DB has {foo: "old", bar: "existing"}
  RDB has: {foo: "new", baz: "added"}
  After:   DB has {foo: "new", bar: "existing", baz: "added"}

  ---
  RDBFLAGS_FEED_REPL (1 << 3)

  When: Primary loads RDB at startup while replicas are connected.

  Effects:
  - As keys load, synthesize replication commands so replicas stay in sync
  - Expired keys during load generate DEL commands to replicas (rdb.c:3442)

  // server.c:6927 — startup with connected replicas
  if (hasActiveReplicas()) {
      createReplicationBacklog();
      rdb_flags |= RDBFLAGS_FEED_REPL;  // Replicate loading to replicas
  }

  ---
  RDBFLAGS_KEEP_CACHE (1 << 4)

  When: The RDB file will be read again soon (replication, shutdown-restart).

  Effects:
  - Skips posix_fadvise(DONTNEED) which would evict file data from OS page cache
  - Normally after writing an RDB, Valkey tells the OS "I'm done with this, you can reclaim the
  memory" — this flag prevents that

  // rdb.c:1554 — during save
  if (!(rdbflags & RDBFLAGS_KEEP_CACHE))
      rioSetReclaimCache(&rdb, 1);  // Tell OS to drop pages after writing

  // replication.c:976 — keep cache for imminent replica read
  rdbSaveBackground(..., RDBFLAGS_REPLICATION | RDBFLAGS_KEEP_CACHE);

  ---
  Common Flag Combinations
  ┌───────────────────────┬────────────────────────────────────────────┐
  │       Scenario        │                   Flags                    │
  ├───────────────────────┼────────────────────────────────────────────┤
  │ Normal BGSAVE         │ RDBFLAGS_NONE                              │
  ├───────────────────────┼────────────────────────────────────────────┤
  │ AOF rewrite           │ RDBFLAGS_AOF_PREAMBLE                      │
  ├───────────────────────┼────────────────────────────────────────────┤
  │ Full sync to replica  │ RDBFLAGS_REPLICATION | RDBFLAGS_KEEP_CACHE │
  ├───────────────────────┼────────────────────────────────────────────┤
  │ Startup with replicas │ RDBFLAGS_FEED_REPL                         │
  ├───────────────────────┼────────────────────────────────────────────┤
  │ DEBUG RELOAD MERGE    │ RDBFLAGS_ALLOW_DUP                         │
  ├───────────────────────┼────────────────────────────────────────────┤
  │ Shutdown save         │ RDBFLAGS_KEEP_CACHE (restart expected)     │
  └───────────────────────┴────────────────────────────────────────────┘
```

**rdbSaveRio:**
```C
rdbSaveRio {
    // Save MAGIC_STRING
    snprintf(magic, sizeof(magic), "VALKEY%03d", RDB_VERSION);
    if (rdbWriteRaw(rdb, magic, 9) == -1) goto werr;
    
    // Auxiliary fields, rdbSaveInfoAuxFields
    rdbSaveInfoAuxFields(rdb, rdbflags, rsi) {
        /* Add a few fields about the state when the RDB was created. */
        if (rdbSaveAuxFieldStrStr(rdb, "valkey-ver", VALKEY_VERSION) == -1) return -1;
        if (rdbSaveAuxFieldStrInt(rdb, "redis-bits", redis_bits) == -1) return -1;
        if (rdbSaveAuxFieldStrInt(rdb, "ctime", time(NULL)) == -1) return -1;
        if (rdbSaveAuxFieldStrInt(rdb, "used-mem", zmalloc_used_memory()) == -1) return -1;
        
        /* Handle saving options that generate aux fields. */
        if (rsi) {
            if (rdbSaveAuxFieldStrInt(rdb, "repl-stream-db", rsi->repl_stream_db) == -1) return -1;
            if (rdbSaveAuxFieldStrStr(rdb, "repl-id", server.replid) == -1) return -1;
            if (rdbSaveAuxFieldStrInt(rdb, "repl-offset", server.primary_repl_offset) == -1) return -1;
        }
        if (rdbSaveAuxFieldStrInt(rdb, "aof-base", aof_base) == -1) return -1;

        /* Handle additional dynamic aux fields */
        if (rdbAuxFields != NULL) {
            dictInitIterator(&di, rdbAuxFields);
            while ((de = dictNext(&di)) != NULL) {
                rdbSaveAuxFieldStrStr(rdb, dictGetKey(de), s)
            }
        }
    }

    /* Iterate over modules, and trigger rdb aux saving for the ones modules types who asked for it. */
    rdbSaveModulesAux(rdb, VALKEYMODULE_AUX_BEFORE_RDB)

    /* save functions */
    rdbSaveFunctions(rdb)

    /* Save the active slot imports to the RDB file. The import job name and the slot ranges are saved.
     * Ref: Prevent exposure of importing keys on replicas during atomic slot migration. https://github.com/valkey-io/valkey/pull/2635 */
    clusterRDBSaveSlotImports(rdb)
    for (j = 0; j < server.dbnum; j++) {
        rdbSaveDb(rdb, j, rdbflags, &key_counter) {
            rdbSaveType(rdb, RDB_OPCODE_SELECTDB)
            rdbSaveLen(rdb, dbid))
            rdbSaveType(rdb, RDB_OPCODE_RESIZEDB)
            rdbSaveLen(rdb, db_size)
            rdbSaveLen(rdb, expires_size)
            while (kvstoreIteratorNext(kvs_it, &next)) {
                /* Save slot info. */
                if (server.cluster_enabled && curr_slot != last_slot)
                    rdbSaveAuxFieldStrStr(rdb, "slot-info", slot_info)
                /* Save a key-value pair, with expire time, type, key, value. */
                rdbSaveKeyValuePair(rdb, &key, o, expire, dbid) {
                    /* Save the expire time */
                    if (expiretime != -1) {
                        rdbSaveType(rdb, RDB_OPCODE_EXPIRETIME_MS)
                        rdbSaveMillisecondTime(rdb, expiretime)
                    }
                    /* Save the LRU info. */
                    if (savelru) {
                        rdbSaveType(rdb, RDB_OPCODE_IDLE)
                        rdbSaveLen(rdb, idletime) == -1)
                    }
                    /* Save the LFU info. */
                    if (savelfu) {
                        rdbSaveType(rdb, RDB_OPCODE_FREQ) == -1) return -1;
                        rdbWriteRaw(rdb, buf, 1) == -1) return -1;
                    }
                    /* Save type, key, value */
                    rdbSaveObjectType(rdb, val
                    rdbSaveStringObject(rdb, key
                    rdbSaveObject(rdb, val, key, dbid)
                }
            }
        }
    }
    rdbSaveModulesAux(rdb, VALKEYMODULE_AUX_AFTER_RDB)
    /* EOF opcode */
    rdbSaveType(rdb, RDB_OPCODE_EOF)
    /* CRC64 checksum. It will be zero if checksum computation is disabled, the
     * loading code skips the check in this case. */
    rioWrite(rdb, &cksum, 8)
```

**Replication socket creation:**

```C
connSocketAcceptHandler {
  *connCreateAcceptedSocket(int fd, void *priv) {
    connection *conn = connCreateSocket();
  }
  acceptCommonHandler {
    createClient(connection *conn) // Do not send anything related to '\n'
  }
  connAccept {
    connSocketAccept(connection *conn, ConnectionCallbackFunc accept_handler) {
      callHandler(conn, accept_handler) {
        clientAcceptHandler(conn) {
					// Do not send anything related to '\n'
        }
      }
    }
  }
}
```

**rdbLoadRio:**
```C
rdbLoadRio
  // Load an RDB file from the rio stream 'rdb'.
  rdbLoadRioWithLoadingCtxScopedRdb(rio *rdb, int rdbflags, rdbSaveInfo *rsi, rdbLoadingCtx *rdb_loading_ctx)
    // Read Magic String
    rioRead(rdb, buf, 9)
    buf[9] = '\0';
    if (memcmp(buf, "REDIS0", 6) == 0) {
        is_redis_magic = true;
    } else if (memcmp(buf, "VALKEY", 6) == 0) {
        is_valkey_magic = true;
    }
    // Read Version
    rdbver = atoi(buf + 6);
    rdbIsVersionAccepted(rdbver, is_valkey_magic, is_redis_magic) {
      if (rdbver < 1) return false;
      if (is_valkey_magic && rdbver <= RDB_FOREIGN_VERSION_MAX) return false;
      if (is_redis_magic && rdbver > RDB_FOREIGN_VERSION_MAX) return false;
      if (server.rdb_version_check == RDB_VERSION_CHECK_STRICT) {
          if (rdbver > RDB_VERSION) return false; /* future version */
          if (rdbIsForeignVersion(rdbver)) return false;
      }
      return true;
    }

    while (1) {
      type = rdbLoadType(rdb)
      /* Safeguard for unknown foreign opcode interpretations. */
      if (is_redis_magic && type >= RDB_FOREIGN_TYPE_MIN && type <= RDB_FOREIGN_TYPE_MAX) {
        return C_ERR;
      }
  
      if (type == RDB_OPCODE_EXPIRETIME) {
        expiretime = rdbLoadTime(rdb);
        expiretime *= 1000;
      } else if (type == RDB_OPCODE_EXPIRETIME_MS) {
        expiretime = rdbLoadMillisecondTime(rdb, rdbver);
      } else if (type == RDB_OPCODE_FREQ) {
        if (rioRead(rdb, &byte, 1) == 0) goto eoferr;
        lfu_freq = byte;
      } else if (type == RDB_OPCODE_IDLE) {
        if ((qword = rdbLoadLen(rdb, NULL)) == RDB_LENERR) goto eoferr;
        lru_idle = qword;
      } else if (type == RDB_OPCODE_EOF) {
        break;
      } else if (type == RDB_OPCODE_SELECTDB) {
        /* SELECTDB: Select the specified database. */
        if ((dbid = rdbLoadLen(rdb, NULL)) == RDB_LENERR) goto eoferr;
        if (rdb_loading_ctx->dbarray[dbid] == NULL) {
          rdb_loading_ctx->dbarray[dbid] = createDatabase(dbid);
        }
        db = rdb_loading_ctx->dbarray[dbid];
      } else if (type == RDB_OPCODE_RESIZEDB) {
        if ((db_size = rdbLoadLen(rdb, NULL)) == RDB_LENERR) goto eoferr;
        if ((expires_size = rdbLoadLen(rdb, NULL)) == RDB_LENERR) goto eoferr;
        should_expand_db = 1;
      } else if (type == RDB_OPCODE_SLOT_INFO) {
        uint64_t slot_id, slot_size, expires_slot_size;
        if ((slot_id = rdbLoadLen(rdb, NULL)) == RDB_LENERR) goto eoferr;
        if ((slot_size = rdbLoadLen(rdb, NULL)) == RDB_LENERR) goto eoferr;
        if ((expires_slot_size = rdbLoadLen(rdb, NULL)) == RDB_LENERR) goto eoferr;
        if (server.cluster_enabled && slot_id < CLUSTER_SLOTS) {
          if (slot_size) kvstoreHashtableExpand(db->keys, slot_id, slot_size);
          if (expires_slot_size) kvstoreHashtableExpand(db->expires, slot_id, expires_slot_size);
          should_expand_db = 0;
        }
      } else if (type == RDB_OPCODE_SLOT_IMPORT) {
        if (clusterRDBLoadSlotImport(rdb) == C_ERR) goto eoferr;
      } else if (type == RDB_OPCODE_AUX) {
        /* AUX: generic string-string fields. Use to add state to RDB
         * which is backward compatible. Implementations of RDB loading
         * are required to skip AUX fields they don't understand.
         *
         * An AUX field is composed of two strings: key and value. */
        if ((auxkey = rdbLoadStringObject(rdb)) == NULL) goto eoferr;
        if ((auxval = rdbLoadStringObject(rdb)) == NULL) {
            decrRefCount(auxkey);
            goto eoferr;
        }
  
        if (((char *)auxkey->ptr)[0] == '%') {
            serverLog(LL_NOTICE, "RDB '%s': %s", (char *)auxkey->ptr, (char *)auxval->ptr);
        } else if (!strcasecmp(auxkey->ptr, "repl-stream-db")) {
            if (rsi) rsi->repl_stream_db = atoi(auxval->ptr);
        } else if (!strcasecmp(auxkey->ptr, "repl-id")) {
            if (rsi && sdslen(auxval->ptr) == CONFIG_RUN_ID_SIZE) {
                memcpy(rsi->repl_id, auxval->ptr, CONFIG_RUN_ID_SIZE + 1);
                rsi->repl_id_is_set = 1;
            }
        } else if (!strcasecmp(auxkey->ptr, "repl-offset")) {
            if (rsi) rsi->repl_offset = strtoll(auxval->ptr, NULL, 10);
        } else if (!strcasecmp(auxkey->ptr, "lua")) {
            /* Won't load the script back in memory anymore. */
        } else if (!strcasecmp(auxkey->ptr, "redis-ver")) {
            serverLog(LL_NOTICE, "Loading RDB produced by Redis version %s", (char *)auxval->ptr);
        } else if (!strcasecmp(auxkey->ptr, "valkey-ver")) {
            serverLog(LL_NOTICE, "Loading RDB produced by Valkey version %s", (char *)auxval->ptr);
        } else if (!strcasecmp(auxkey->ptr, "ctime")) {
            time_t age = time(NULL) - strtol(auxval->ptr, NULL, 10);
            if (age < 0) age = 0;
            serverLog(LL_NOTICE, "RDB age %ld seconds", (unsigned long)age);
        } else if (!strcasecmp(auxkey->ptr, "used-mem")) {
            long long usedmem = strtoll(auxval->ptr, NULL, 10);
            serverLog(LL_NOTICE, "RDB memory usage when created %.2f Mb", (double)usedmem / (1024 * 1024));
            server.loading_rdb_used_mem = usedmem;
        } else if (!strcasecmp(auxkey->ptr, "aof-preamble")) {
            long long haspreamble = strtoll(auxval->ptr, NULL, 10);
            if (haspreamble) serverLog(LL_NOTICE, "RDB has an AOF tail");
        } else if (!strcasecmp(auxkey->ptr, "aof-base")) {
            long long isbase = strtoll(auxval->ptr, NULL, 10);
            if (isbase) serverLog(LL_NOTICE, "RDB is base AOF");
        } else if (!strcasecmp(auxkey->ptr, "redis-bits")) {
            /* Just ignored. */
        } else if (!strcasecmp(auxkey->ptr, "slot-info")) {
            if (sscanf(auxval->ptr, "%i,%lu,%lu,%lu",
                       &slot_id, &slot_size, &expires_slot_size,
                       &keys_with_volatile_items_slot_size) < 3) {
                decrRefCount(auxkey);
                decrRefCount(auxval);
                goto eoferr;
            }
  
            if (server.cluster_enabled && slot_id >= 0 && slot_id < CLUSTER_SLOTS) {
                if (slot_size) kvstoreHashtableExpand(db->keys, slot_id, slot_size);
                if (expires_slot_size) kvstoreHashtableExpand(db->expires, slot_id, expires_slot_size);
                if (keys_with_volatile_items_slot_size) {
                    kvstoreHashtableExpand(db->keys_with_volatile_items,
                                           slot_id,
                                           keys_with_volatile_items_slot_size);
                }
                should_expand_db = 0;
            }
        } else {
            if (rdbAuxFields != NULL) {
                dictEntry *de = dictFind(rdbAuxFields, auxkey->ptr);
                if (de != NULL) {
                    handled = 1;
                    rdbAuxFieldCodec *codec = (rdbAuxFieldCodec *)dictGetVal(de);
                    if (codec->decoder(rdbflags, auxval->ptr) == C_ERR) {
                        goto eoferr;
                    }
                }
            }
        }
      } else if (type == RDB_OPCODE_MODULE_AUX) {
        uint64_t moduleid = rdbLoadLen(rdb, NULL);
        int when_opcode = rdbLoadLen(rdb, NULL);
        int when = rdbLoadLen(rdb, NULL);
        if (when_opcode != RDB_MODULE_OPCODE_UINT) {
          goto eoferr;
        }
        moduleType *mt = moduleTypeLookupModuleByID(moduleid);
        char name[10];
        moduleTypeNameByID(name, moduleid);
        
        moduleInitIOContext(&io, mt, rdb, NULL, -1);
        int rc = mt->aux_load(&io, moduleid & 1023, when);
        moduleTypeNameByID(name, moduleid);
        uint64_t eof = rdbLoadLen(rdb, NULL);
        robj *aux = rdbLoadCheckModuleValue(rdb, name);
      } else if (type == RDB_OPCODE_FUNCTION2) {
        rdbFunctionLoad(rdb, rdbver, rdb_loading_ctx->functions_lib_ctx, rdbflags, &err)
      }
      
      /* If there is no slot info, it means that it's either not cluster mode or we are trying to load legacy RDB
       * file. In this case we want to estimate number of keys per slot and resize accordingly. */
      if (should_expand_db) {
          dbExpand(db, db_size, 0);
          dbExpandExpires(db, expires_size, 0);
          should_expand_db = 0;
      }
      
      /* Read key */
      if ((key = rdbGenericLoadStringObject(rdb, RDB_LOAD_SDS, NULL)) == NULL) goto eoferr;
      /* Read value */
      val = rdbLoadObject(type, rdb, key, db->id, &error);
      
      /* Add the new object in the hash table */
      int added = dbAddRDBLoad(db, key, &val);
  
      /* Verify the checksum if RDB version is >= 5 */
      if (rdbver >= 5) {
        uint64_t cksum, expected = rdb->cksum;
        memrev64ifbe(&cksum);
        if (cksum != expected) {
          return C_ERR;
        }
      }
    }
  }
}
```

# Where '\n' comes from?

```C
replicationCron {
  /* Second, send a newline to all the replicas in pre-synchronization
   * stage, that is, replicas waiting for the primary to create the RDB file.
   *
   * Also send the a newline to all the chained replicas we have, if we lost
   * connection from our primary, to keep the replicas aware that their
   * primary is online. This is needed since sub-replicas only receive proxied
   * data from top-level primaries, so there is no explicit pinging in order
   * to avoid altering the replication offsets. This special out of band
   * pings (newlines) can be sent, they will have no effect in the offset.
   *
   * The newline will be ignored by the replica but will refresh the
   * last interaction timer preventing a timeout. In this case we ignore the
   * ping period and refresh the connection once per second since certain
   * timeouts are set at a few seconds (example: PSYNC response). */
	listRewind(server.replicas, &li);
	while ((ln = listNext(&li))) {
		if (is_presync) {
			connWrite(replica->conn, "\n", 1);
		}
	}
}
```

```C
/* Avoid the primary to detect the replica is timing out while loading the
 * RDB file in initial synchronization. We send a single newline character
 * that is valid protocol but is guaranteed to either be sent entirely or
 * not, since the byte is indivisible.
 *
 * The function is called in two contexts: while we flush the current
 * data with emptyData(), and while we load the new data received as an
 * RDB file from the primary. */
void replicationSendNewlineToPrimary(void) {
	static time_t newline_sent;
	if (time(NULL) != newline_sent) {
		newline_sent = time(NULL);
		/* Pinging back in this stage is best-effort. */
		if (server.repl_transfer_s) connWrite(server.repl_transfer_s, "\n", 1);
	}
}
```

